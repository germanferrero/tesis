@inproceedings{10.1007/11804192_17,
  author    = {Barnett, Mike
               and Chang, Bor-Yuh Evan
               and DeLine, Robert
               and Jacobs, Bart
               and Leino, K. Rustan M.},
  editor    = {de Boer, Frank S.
               and Bonsangue, Marcello M.
               and Graf, Susanne
               and de Roever, Willem-Paul},
  title     = {Boogie: A Modular Reusable Verifier for Object-Oriented Programs},
  booktitle = {Formal Methods for Components and Objects},
  year      = {2006},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {364--387},
  abstract  = {A program verifier is a complex system that uses compiler technology, program semantics, property inference, verification-condition generation, automatic decision procedures, and a user interface. This paper describes the architecture of a state-of-the-art program verifier for object-oriented programs.},
  isbn      = {978-3-540-36750-5}
}

@inproceedings{10.1007/978-3-030-99524-9_23,
  author    = {Chakarov, Aleksandar
               and Fedchin, Aleksandr
               and Rakamari{\'{c}}, Zvonimir
               and Rungta, Neha},
  editor    = {Fisman, Dana
               and Rosu, Grigore},
  title     = {Better Counterexamples for Dafny},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems},
  year      = {2022},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {404--411},
  abstract  = {Dafny is a verification-aware programming language used at Amazon Web Services to develop critical components of their access management, storage, and cryptography infrastructures. The Dafny toolchain provides a verifier that can prove an implementation of a method satisfies its specification. When the underlying SMT solver cannot establish a proof, it generates a counterexample. These counterexamples are hard to understand and their interpretation is often a bottleneck in the proof debugging process. In this paper, we introduce an open-source tool that transforms counterexamples generated by the SMT solver to a more user-friendly format that maps to the Dafny syntax and is suitable for further processing. This new tool allows the Dafny developers to quickly identify the root cause of a problem with their proof, thereby speeding up the development of Dafny projects.},
  isbn      = {978-3-030-99524-9}
}


@inproceedings{10.1007/BFb0055136,
  author    = {Harrison, John},
  editor    = {Grundy, Jim
               and Newey, Malcolm},
  title     = {Formalizing Dijkstra},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {1998},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {171--188},
  abstract  = {We present a HOL formalization of the foundational parts of Dijkstra's classic monograph ``A Discipline of Programming≓. While embedding programming language semantics in theorem provers is hardly new, this particular undertaking raises several interesting questions, and perhaps makes an interesting supplement to the monograph. Moreover, the failure of HOL's first order proof tactic to prove one `theorem' indicates a technical error in the book.},
  isbn      = {978-3-540-49801-8}
}

@article{10.1007/s00165-019-00501-3,
  author     = {Apt, Krzysztof R. and Olderog, Ernst-R\"{u}diger},
  title      = {Fifty years of Hoare’s logic},
  year       = {2019},
  issue_date = {Dec 2019},
  publisher  = {Springer-Verlag},
  address    = {Berlin, Heidelberg},
  volume     = {31},
  number     = {6},
  issn       = {0934-5043},
  url        = {https://doi.org/10.1007/s00165-019-00501-3},
  doi        = {10.1007/s00165-019-00501-3},
  abstract   = {We present a history of Hoare’s logic.},
  journal    = {Form. Asp. Comput.},
  month      = dec,
  pages      = {751–807},
  numpages   = {57}
}


@inproceedings{10.1145/1108792.1108813,
  author    = {Barnett, Mike and Leino, K. Rustan M.},
  title     = {Weakest-precondition of unstructured programs},
  year      = {2005},
  isbn      = {1595932399},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1108792.1108813},
  doi       = {10.1145/1108792.1108813},
  abstract  = {Program verification systems typically transform a program into a logical expression which is then fed to a theorem prover. The logical expression represents the weakest precondition of the program relative to its specification; when (and if!) the theorem prover is able to prove the expression, then the program is considered correct. Computing such a logical expression for an imperative, structured program is straightforward, although there are issues having to do with loops and the efficiency both of the computation and of the complexity of the formula with respect to the theorem prover. This paper presents a novel approach for computing the weakest precondition of an unstructured program that is sound even in the presence of loops. The computation is efficient and the resulting logical expression provides more leeway for the theorem prover efficiently to attack the proof.},
  booktitle = {Proceedings of the 6th ACM SIGPLAN-SIGSOFT Workshop on Program Analysis for Software Tools and Engineering},
  pages     = {82–87},
  numpages  = {6},
  location  = {Lisbon, Portugal},
  series    = {PASTE '05}
}


@unpublished{EWD:EWD418,
  author   = {Edsger W. Dijkstra},
  title    = {Guarded commands, non-determinacy and a calculus for the derivation of programs},
  month    = {jun},
  year     = {1974},
  note     = {see {\cite EWD:EWD472}; circulated privately},
  url      = {http://www.cs.utexas.edu/users/EWD/ewd04xx/EWD418.PDF},
  filesize = {305 KB}
}

@inbook{Leino2001,
  author    = {Leino, K. Rustan M.},
  editor    = {Wilhelm, Reinhard},
  title     = {Extended Static Checking: A Ten-Year Perspective},
  booktitle = {Informatics: 10 Years Back, 10 Years Ahead},
  year      = {2001},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {157--175},
  abstract  = {A powerful approach to finding errors in computer software is to translate a given program into a verification condition, a logical formula that is valid if and only if the program is free of the classes of errors under consideration. Finding errors in the program is then done by mechanically searching for counterexamples to the verification condition. This paper gives an overview of the technology that goes into such program checkers, reports on some of the progress and lessons learned in the past ten years, and identifies some remaining challenges.},
  isbn      = {978-3-540-44577-7},
  doi       = {10.1007/3-540-44577-3_11},
  url       = {https://doi.org/10.1007/3-540-44577-3_11}
}