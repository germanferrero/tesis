\documentclass[11pt, a4paper, openany]{book}
\usepackage{amsmath, amssymb,}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{relsize}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\linespread{1.1}
\author{Germán Ferrero}
\title{Construcción formal de programas asistida por Dafny}
\begin{document}
    \chapter{Introducción}
    En el libro Cálculo de Programas (en adelante simplemente ``el libro''), se busca introducir al estudiante en la construcción de programas imperativos a través de un método formal para derivar el programa a partir de su especificación. La misma debe estar definida por una precondición y una postcondición, ambas escritas como fórmulas del cálculo de predicados estudiado en la materia pre correlativa ``Introducción a los Algoritmos''. El método consiste en tender puentes entre los bloques constructivos de un lenguaje imperativo (\textit{if}, \textit{for}, asignación, \textit{skip}, etc) y el cálculo de predicados. De manera tal que uno pueda plantear el esqueleto de un programa de manera creativa, y concluir los detalles razonando - o calculando - sobre el terreno ya conocido del cálculo de predicados.

    En mi opinión el libro tiene algunas características que merecen revisión:
    \begin{itemize}
    \item Utiliza, de manera casi exclusiva, un lenguaje formal que privilegia la especificidad, pero sacrifica legibilidad y facilidad de interpretación.
    \item En ocasiones pasa por alto el origen de las estrategias creativas necesarias para construir programas, introduciendo \\esqueletos'' sin mucho preámbulo, y restringiendo el foco de atención a la derivación de las sentencias que constituyen el resto del programa y sí pueden derivarse mediante el método formal.
    \item Los programas obtenidos y sus pruebas, no están escritos en computadora, y por tanto no pueden ser ejecutados ni verificados de forma automática.
    \end{itemize}

    Nuestra hipótesis, es que resultaría más provechoso para el proceso de aprendizaje, primero, introducir la programación imperativa con ejemplos en un lenguaje no formal. Luego, con el lector y su intuición a bordo, identificar en los ejemplos la utilidad de los conceptos básicos (transformación de estado, precondición, postcondición, invariante, etc) y finalmente proceder a la formalización de los mismos para luego poder probar (formalmente), la corrección de los programas obtenidos y resolver problemas más complejos asistidos por una metodología similar a la del libro pero adaptada al uso de Dafny, un lenguaje de programación con soporte para la declaración de especificaciones, pruebas y un entorno de desarrollo capaz de verificar los programas de manera automática.

    A lo largo de este trabajo desarrollamos esta estrategia alternativa.
    % TODO: Revisar más adelante qué texto resume mejor cada capítulo.%
    [WIP]
    En el capítulo 2 presentamos ejemplos de problemas simples que pueden resolverse con programación imperativa. Apelamos a la intuición y la creatividad para construir los programas e identificamos en ellos los conceptos fundamentales.
    En el capítulo 3 los formalizamos (...)
    En el capítulo 4 realizamos pruebas formales de correctitud utilizando Dafny. (...)[END-WIP]

    \chapter{Introducción a la programación imperativa}
    [WIP](...)

    \subsection{Duplicar}
    Queremos obtener un programa $P$ que dado un número entero cualquiera lo duplique. Este simple programa, que finalmente resultará en una línea de código similar a esta:
    \begin{verbatim}
        y = x * 2  # Pseudocódigo
    \end{verbatim}
    nos servirá para razonar sobre qué es un programa imperativo.


    En primer lugar, necesitamos ``recibir'' o ``leer'' de alguna forma el número en cuestión, para conocer su valor, y luego poder ``devolver'' o ``escribir'' de alguna forma su valor duplicado, una vez que lo calculemos.
    En la programación imperativa el mecanismo que utilizaremos para satisfacer ambas necesidades es el de \textit{transformación de estado}.
    Un \textit{estado} será una colección de nombres de variables y sus valores. Al \textit{ejecutar} un programa lo que estaremos haciendo es transformar potencialmente ese estado, sea agregando nuevas variables, modificando el valor de las variables existentes, o dejándolo tal cual lo recibimos.
    En este caso podemos pensar en un programa que se ejecutará a partir de un estado con una única variable $x$ que tiene el valor del número que queremos duplicar y, al finalizar la ejecución, habrá escrito el resultado en una variable adicional $y$, obteniendo un estado con dos variables $x$ e $y$.

    Ahora bien,
    ¿Qué pasa si $x$ no está en el estado al ejecutarlo?
    ¿Qué pasa si el valor de $x$ no es un entero?
    ¿Qué relación esperamos se cumpla entre $x$ e $y$ luego de la ejecución?

    Respondernos estas preguntas puntillosamente dará resultado a una \textit{especificación} del programa.
    Decidiremos, por ejemplo, que no nos interesa qué sucede al ejecutar $P$ si $x$ no está en el estado y por tanto que $P$ nunca se ejecutará en ese caso. Lo mismo aplica en caso de que el valor de $x$ no sea un entero. Es decir, pondremos como precondición de nuestro programa que $x$ esté definida y su valor sea un número entero. Por último queremos que nuestro programa garantice que en el estado final el valor de $y$ sea exactamente el doble de $x$. Esta será nuestra postcondición.

    En efecto, nuestro programa será especificado por una \textit{precondición} y una \textit{postcondición}

    Aún quedan preguntas sin resolver:
    ¿Qué pasa si nuestro programa cumple con la postcondición, pero en el camino, no solo modificó $y$ sino también $x$? Para resolver este problema necesitamos que, para nuestro programa, $x$ no sea una variable sino una \textit{constante} (es decir, que no pueda ser modificada).
    ¿Algún otro programa estará consultando el estado además del nuestro?¿Tenemos que especificarle a nuestro programa que no modifique variables que no debe? Por el momento, pensaremos nuestro programa como el único que leerá y escribirá el estado. Puede modificar las variables que desee, siempre que cumpla con la postcondición.

    Nos resultará muy útil emplear \textit{predicados} para escribir la precondición $Q$ y la postcondición $R$ en lenguaje formal:

    \begin{math}
        Q: \lbrace const\,x \in Int \rbrace
    \end{math}


    \begin{math}
        R: \lbrace const\,x \in Int,\; var\,y \in Int\;|\;y = x * 2 \rbrace
    \end{math}

    Nuestro programa será correcto si cumple con su especificación, es decir, si siempre que parte de un estado que satisface $Q$ llega a un estado que satisface $R$.

    [WIP]: (Introduccion de la asignación)

    \subsection{El valor absoluto de un número entero}
    [WIP]: (Introduccion del if)

    \subsection{La división de números enteros}
    Queremos obtener un programa que dados dos números $x$ e $y$, compute el cociente $q$ y el resto $r$ de la división entera de $x$ por $y$.
    Recordemos que el cociente y el resto cumplen:
    $$x = y * q + r$$
    Ahora bien, ¿cómo podemos computar $q$ y $r$, para cualquier $x$ e $y$ dados?
    Una alternativa razonable es construir iterativamente tanto $q$ como $r$, partiendo de valores iniciales y acercándolos en cada paso a su valor final.
    Si en todo momento, mantenemos la cantidad de $x$ distribuída entre cierta cantidad de $y$’s (esto es $q$) y el resto que falta para llegar a cubrir $x$ (esto es $r$), entonces podemos imaginar un ciclo en el que empezamos con $q$ igual a 0 y todo $x$ está en $r$.
    Luego en cada paso, y mientras podamos extraer una cantidad $y$ de $r$, la sustraemos de ahí y la pasamos a $q$.
    Es decir, empezamos con:
    \begin{verbatim}
        q:=0;
        r:=x;
    \end{verbatim}
    Y en cada paso mientras que $r \geq y$, ejecutamos
    \begin{verbatim}
        q:=q + 1;
        r:=r - y;
    \end{verbatim}

    Y así sucesivamente hasta que $y$ no quepe en $r$ ( $ y > r $ ). Para entonces $q$ y $r$ serán respectivamente el cociente y el resto de la división de $x$ por $y$.

    Nuestro programa final será:
    \begin{verbatim}
    q:=0;
    r:=x;
    do r >=y
        q:=q+1;
        r:=r-y;
    od
    \end{verbatim}
    Notemos en este programa simple, que:
    \begin{itemize}
        \item En todo momento se cumple:
        $$x = q * y + r$$
        Este es nuestro \textit{invariante}, y proviene de nuestra estrategia inicial de tener distribuído $x$, paso a paso, entre $q$ y $r$.
        \item Que debemos continuar iterando mientras que $r >= y$,
        Esta es nuestra \textit{guarda}.
        \item Que si se cumple el invariante y la guarda deja de cumplirse entonces hemos terminado.
        \item Y que a su vez, estamos seguros de que en algún momento la guarda dejará de cumplirse, por que en cada paso reducimos $r$.
    \end{itemize}

    Este desarrollo alternativo, pone foco en presentar al lector una estrategia de resolución iterativa del problema, acudiendo a la experiencia común entre las personas de ``pasar cosas'' de un lugar a otro, y cómo esa estrategia puede traducirse en un programa concreto.
    La esperanza, es que al finalizar la explicación, el lector esté en mejores condiciones de identificar otros problemas que puedan resolverse programando ciclos, y la importancia que el invariante adquiere como sostén de la estrategia iterativa de resolución.
    \chapter{Dafny}
    Continuará.
\end{document}
