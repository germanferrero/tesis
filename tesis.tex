\documentclass[12pt, a4paper, openany, fleqn]{book}
\usepackage{amsmath, amssymb,}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{relsize}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{xcolor}
\usepackage{dafny}
\renewcommand{\lstlistingname}{Ejemplo}
\linespread{1.1}
\author{Germán Ferrero}
\title{Construcción formal de programas asistida por Dafny}
\begin{document}
    \chapter{Introducción}
    En el libro Cálculo de Programas (en adelante simplemente ``el libro''), se busca introducir al estudiante en la construcción de programas imperativos a través de un método formal para derivar el programa a partir de su especificación. La misma debe estar definida por una precondición y una postcondición, ambas escritas como fórmulas del cálculo de predicados estudiado en la materia pre correlativa ``Introducción a los Algoritmos''. El método consiste en tender puentes entre los bloques constructivos de un lenguaje imperativo (\textit{if}, \textit{for}, asignación, \textit{skip}, etc) y el cálculo de predicados. De manera tal que uno pueda plantear el esqueleto de un programa de manera creativa, y concluir los detalles razonando - o calculando - sobre el terreno ya conocido del cálculo de predicados.

    En mi opinión el libro tiene algunas características que merecen revisión:
    \begin{itemize}
    \item Utiliza, de manera casi exclusiva, un lenguaje formal que privilegia la especificidad, pero sacrifica legibilidad y facilidad de interpretación.
    \item En ocasiones pasa por alto el origen de las estrategias creativas necesarias para construir programas, introduciendo ``esqueletos'' de programas sin mucho preámbulo, y restringiendo el foco de atención a la derivación de las sentencias que constituyen el resto del programa y sí pueden derivarse mediante el método formal.
    \item Los programas obtenidos y sus pruebas, no están escritos en computadora, y por tanto no pueden ser ejecutados ni verificados de forma automática.
    \end{itemize}

    Nuestra hipótesis, es que resultaría más provechoso para el proceso de aprendizaje, primero, introducir la programación imperativa con ejemplos en un lenguaje no formal. Luego, con el lector y su intuición a bordo, identificar en los ejemplos la utilidad de los conceptos básicos (transformación de estado, precondición, postcondición, invariante, etc) y finalmente proceder a la formalización de los mismos para luego poder probar (formalmente), la corrección de los programas obtenidos y resolver problemas más complejos asistidos por una metodología similar a la del libro pero adaptada al uso de Dafny, un lenguaje de programación con soporte para la declaración de especificaciones, pruebas y un entorno de desarrollo capaz de verificar los programas de manera automática.

    A lo largo de este trabajo desarrollamos esta estrategia alternativa.
    % TODO: Revisar más adelante qué texto resume mejor cada capítulo.%
    [WIP]
    En el capítulo 2 presentamos ejemplos de problemas simples que pueden resolverse con programación imperativa. Apelamos a la intuición y la creatividad para construir los programas e identificamos en ellos los conceptos fundamentales.
    En el capítulo 3 los formalizamos (...)
    En el capítulo 4 realizamos pruebas formales de correctitud utilizando Dafny. (...)[END-WIP]

    \chapter{Introducción a la programación imperativa}
    [WIP](...)

    \subsection{Duplicar}
    \subsubsection*{La especificación de un programa}

    Queremos obtener un programa $S$ que dado un número entero cualquiera lo duplique. Este simple programa, que finalmente resultará en una línea de código similar a esta:
    \begin{verbatim}
        y = x * 2  # Pseudocódigo
    \end{verbatim}
    nos servirá para especificar acabadamente qué es un programa imperativo.


    En primer lugar, necesitamos ``recibir'' o ``leer'' de alguna forma el número en cuestión, para conocer su valor, y luego poder ``devolver'' o ``escribir'' de alguna forma su valor duplicado, una vez que lo calculemos.
    En la programación imperativa el mecanismo que utilizaremos para satisfacer ambas necesidades es el de \textit{transformación de estado}.
    Un \textit{estado} será una colección de nombres de variables y sus valores. Al \textit{ejecutar} un programa lo que estaremos haciendo es transformar potencialmente ese estado, sea agregando nuevas variables, modificando el valor de las variables existentes, o dejándolo tal cual lo recibimos.

    En este caso podemos pensar en un programa que se ejecutará a partir de un estado con una variable $x$, que aloja el valor del número que queremos duplicar y una variable $y$ donde depositaremos el resultado.

    Ahora bien,
    ¿Qué hará el programa si $x$ no está en el estado al ser ejecutado?
    ¿Qué hará si el valor de $x$ no es un entero?
    ¿Qué relación esperamos se cumpla entre $x$ e $y$ luego de la ejecución?

    Respondernos estas preguntas puntillosamente dará resultado a una \textit{especificación} del programa.
    Decidiremos, por ejemplo, que no nos interesa qué sucede al ejecutar $S$ si $x$ no está en el estado y por tanto que $S$ nunca se ejecutará en ese caso. Lo mismo aplica en caso de que el valor de $x$ no sea un entero. Es decir, pondremos como precondición de nuestro programa que $x$ esté definida y su valor sea un número entero y que $y$ esté definida aunque su valor sea un número entero arbitrario. Por último queremos que nuestro programa garantice que en el estado final el valor de $y$ sea exactamente el doble de $x$. Esta será nuestra postcondición.

    En efecto, nuestro programa será especificado por una \textit{precondición} y una \textit{postcondición}

    Aún quedan preguntas sin resolver:
    ¿Qué pasa si nuestro programa cumple con la postcondición, pero en el camino, no solo modificó $y$ sino también $x$? Para resolver este problema necesitamos que, para nuestro programa, $x$ no sea una variable sino una \textit{constante} (es decir, que no pueda ser modificada).
    ¿Algún otro programa estará consultando el estado además del nuestro?¿Tenemos que especificarle a nuestro programa que no modifique variables que no debe? Por el momento, pensaremos nuestro programa como el único que leerá y escribirá el estado. Puede modificar las variables que desee, siempre que cumpla con la postcondición.

    Nos resultará muy útil emplear \textit{predicados} para escribir la precondición y la postcondición de nuestros programas. En este caso:

    \begin{align*}
        [[& \text{const x} \in \mathbb{Z} \\
          & \text{var y} \in \mathbb{Z} \\
          & \lbrace {True} \rbrace \\
          & S \\
          & \lbrace {y = x * 2} \rbrace \\
        ]]
    \end{align*}

    Notese que la precondición es $True$ pues lo único que debe cumplirse es la existencia de la constante $x$ y la variable $y$ en el estado.
    Hasta aquí, utilizando los conceptos de estado, predicados, y transformación de estados, hemos logrado especificar acabadamente qué debería hacer nuestro programa, aún sin hablar en absoluto de cómo lo hará.

    \subsubsection*{La especificación de un programa en Dafny}

    A lo largo de este trabajo, escribiremos programas formalmente especificados, y verificaremos a través de \textit{pruebas} que sus implementaciones sean correctas, es decir, que cumplan con su especificación.

    Para ayudarnos en esta tarea, utilizaremos Dafny un lenguaje de programación con soporte para declarar especificaciones, y dotado de un entorno de desarrollo capaz de verificar los programas de manera automática.

    Si bien, para programas sencillos como el de duplicar un número entero, la correctitud del programa será evidente con solo inspeccionarlo, a medida que construyamos programas más complejos descubriremos la invaluable tranquilidad de saber que la correctitud de nuestro programa ha sido verificada de manera automática.

    Escribamos entonces la especificación de nuestro programa en Dafny:

    \dafnyfile{examples/01_duplicar.dfy}

    Hemos utilizado el constructor \inlinedafny{method} de Dafny para especificar nuestro programa. La precondición de que exista la constante \begin{math}x \in \mathbb{Z}\end{math}, está especificada por el parámetro \inlinedafny{x:int}, los parámetros de los métodos en Dafny son inmutables. La precondición de que exista la variable \begin{math}y \in \mathbb{Z}\end{math} está especificada por la presencia de \inlinedafny{y:int} en la cláusula \inlinedafny{returns}.
    La postcondición está especificada por la cláusula \inlinedafny{ensures y == x * 2} que especifica la relación que el programa garantiza entre $x$ e $y$ al final de la ejecución.

    \subsubsection*{La asignación}
    Nuestro programa no tiene un cuerpo o implementación aún. El cuerpo de un programa imperativo estará dado por una sucesión sentencias de varios tipos, bien definidos. El primer tipo de sentencia que estudiaremos es la ``asignación''.

    La asignación, (asignación paralela en Dafny) se utiliza para asignar valores a variables y toma la forma \inlinedafny{x, y := E, E';}. Donde a lo que está a la izquierda del operador \inlinedafny{:=} le llamamos Left Hand Side (LHS) y lo que está a la derecha RHS. El LHS puede estar compuesto por una o más variables y el RHS estará compuesto por un número igual de expresiones.

    Las variables que aparecen en el LHS deben haber sido declaradas previamente con una sentencia de declaración de variables. Que toma la forma \inlinedafny{var x;}

    Las expresiones del RHS pueden ser cualquier tipo de expresión en Dafny, pero por el momento nos concentraremos en expresiones aritméticas que combinan números y variables con los operadores aritméticos básicos $+,-,*,/,\%$

    [WIP]: (Semántica de la asignación en términos de predicados, WP, obligación de prueba, pasamano al solver, asignación verificada automáticamente)

    \subsection{El valor absoluto de un número entero}
    [WIP]: (Introduccion del if)

    \subsection{La división de números enteros}
    Queremos obtener un programa que dados dos números $x$ e $y$, compute el cociente $q$ y el resto $r$ de la división entera de $x$ por $y$.
    Recordemos que el cociente y el resto cumplen:
    $$x = y * q + r$$
    Ahora bien, ¿cómo podemos computar $q$ y $r$, para cualquier $x$ e $y$ dados?
    Una alternativa razonable es construir iterativamente tanto $q$ como $r$, partiendo de valores iniciales y acercándolos en cada paso a su valor final.
    Si en todo momento, mantenemos la cantidad de $x$ distribuída entre cierta cantidad de $y$’s (esto es $q$) y el resto que falta para llegar a cubrir $x$ (esto es $r$), entonces podemos imaginar un ciclo en el que empezamos con $q$ igual a 0 y todo $x$ está en $r$.
    Luego en cada paso, y mientras podamos extraer una cantidad $y$ de $r$, la sustraemos de ahí y la pasamos a $q$.
    Es decir, empezamos con:
    \begin{verbatim}
        q:=0;
        r:=x;
    \end{verbatim}
    Y en cada paso mientras que $r \geq y$, ejecutamos
    \begin{verbatim}
        q:=q + 1;
        r:=r - y;
    \end{verbatim}

    Y así sucesivamente hasta que $y$ no quepe en $r$ ( $ y > r $ ). Para entonces $q$ y $r$ serán respectivamente el cociente y el resto de la división de $x$ por $y$.

    Nuestro programa final será:
    \begin{verbatim}
    q:=0;
    r:=x;
    do r >=y
        q:=q+1;
        r:=r-y;
    od
    \end{verbatim}
    Notemos en este programa simple, que:
    \begin{itemize}
        \item En todo momento se cumple:
        $$x = q * y + r$$
        Este es nuestro \textit{invariante}, y proviene de nuestra estrategia inicial de tener distribuído $x$, paso a paso, entre $q$ y $r$.
        \item Que debemos continuar iterando mientras que $r >= y$,
        Esta es nuestra \textit{guarda}.
        \item Que si se cumple el invariante y la guarda deja de cumplirse entonces hemos terminado.
        \item Y que a su vez, estamos seguros de que en algún momento la guarda dejará de cumplirse, por que en cada paso reducimos $r$.
    \end{itemize}

    Este desarrollo alternativo, pone foco en presentar al lector una estrategia de resolución iterativa del problema, acudiendo a la experiencia común entre las personas de ``pasar cosas'' de un lugar a otro, y cómo esa estrategia puede traducirse en un programa concreto.
    La esperanza, es que al finalizar la explicación, el lector esté en mejores condiciones de identificar otros problemas que puedan resolverse programando ciclos, y la importancia que el invariante adquiere como sostén de la estrategia iterativa de resolución.
    \chapter{Dafny}
    Continuará.
\end{document}
