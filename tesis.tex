\documentclass[12pt, a4paper, openany, fleqn]{book}
\usepackage{amsmath, amssymb,}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{relsize}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{xcolor}
\usepackage{dafny}
\usepackage{spverbatim}
\newcommand{\disgrecion}[1]{#1}
\newcommand{\declConst}[2]{\text{const } #1 : #2}
\newcommand{\declVar}[2]{\text{var } #1 : #2}

\renewcommand{\lstlistingname}{Dafny}
\linespread{1.1}
\author{Germán Ferrero}
\title{Construcción formal de programas asistida por Dafny}
\begin{document}
    \chapter{Introducción}
    En el libro Cálculo de Programas (en adelante simplemente ``el libro''), se busca introducir al estudiante en la construcción de programas imperativos a través de un método formal para derivar el programa a partir de su especificación. La misma debe estar definida por una precondición y una postcondición, ambas escritas como fórmulas del cálculo de predicados estudiado en la materia pre correlativa ``Introducción a los Algoritmos''. El método consiste en tender puentes entre los bloques constructivos de un lenguaje imperativo (\textit{if}, \textit{for}, asignación, \textit{skip}, etc) y el cálculo de predicados. De manera tal que uno pueda plantear el esqueleto de un programa de manera creativa, y concluir los detalles razonando - o calculando - sobre el terreno ya conocido del cálculo de predicados.

    En mi opinión el libro tiene algunas características que merecen revisión:
    \begin{itemize}
    \item Utiliza, de manera casi exclusiva, un lenguaje formal que privilegia la especificidad, pero sacrifica legibilidad y facilidad de interpretación.
    \item En ocasiones pasa por alto el origen de las estrategias creativas necesarias para construir programas, introduciendo ``esqueletos'' de programas sin mucho preámbulo, y restringiendo el foco de atención a la derivación de las sentencias que constituyen el resto del programa y sí pueden derivarse mediante el método formal.
    \item Los programas obtenidos y sus pruebas, no están escritos en computadora, y por tanto no pueden ser ejecutados ni verificados de forma automática.
    \end{itemize}

    Nuestra hipótesis, es que resultaría más provechoso para el proceso de aprendizaje, primero, introducir la programación imperativa con ejemplos en un lenguaje no formal. Luego, con el lector y su intuición a bordo, identificar en los ejemplos la utilidad de los conceptos básicos (transformación de estado, precondición, postcondición, invariante, etc) y finalmente proceder a la formalización de los mismos para luego poder probar (formalmente), la corrección de los programas obtenidos y resolver problemas más complejos asistidos por una metodología similar a la del libro pero adaptada al uso de Dafny, un lenguaje de programación con soporte para la declaración de especificaciones, pruebas y un entorno de desarrollo capaz de verificar los programas de manera automática.

    A lo largo de este trabajo desarrollamos esta estrategia alternativa.
    % TODO: Revisar más adelante qué texto resume mejor cada capítulo.%
    [WIP]
    En el capítulo 2 presentamos ejemplos de problemas simples que pueden resolverse con programación imperativa. Apelamos a la intuición y la creatividad para construir los programas e identificamos en ellos los conceptos fundamentales.
    En el capítulo 3 los formalizamos (...)
    En el capítulo 4 realizamos pruebas formales de correctitud utilizando Dafny. (...)[END-WIP]

    \chapter{Introducción a la programación imperativa en Dafny}
    [WIP](...)

    \subsection{Superar un número entero}
    \subsubsection*{La especificación de un programa}

    Queremos obtener un programa que dado un número entero cualquiera nos devuelva otro mayor. Este simple programa, que finalmente resultará en una línea de código similar a esta:
    \begin{verbatim}
        y = x + 1  # Pseudocódigo
    \end{verbatim}
    nos servirá para razonar acerca de qué es un programa imperativo y cómo podemos garantizar su correctitud.

    En primer lugar, necesitamos ``recibir'' o ``leer'' de alguna forma el número en cuestión, para conocer su valor, y luego poder ``devolver'' o ``escribir'' de alguna forma otro valor mayor, una vez que lo calculemos.
    En la programación imperativa el mecanismo que utilizaremos para satisfacer ambas necesidades es el de \textit{transformación de estado}.
    Un \textit{estado} será una colección de nombres de variables y constantes, con sus respectivos valores, a los que el programa tendrá acceso. Cada una de ellas tendrá un tipo asociado (número entero, booleano, cadena de texto, etc). Al \textit{ejecutar} un programa lo que estaremos haciendo es transformar potencialmente ese estado modificando el valor de sus variables.

    En este caso podemos pensar en un programa $S$ que se ejecutará a partir de un estado con una constante $x$ de tipo entero, que aloja el valor de la cantidad a superar y una variable $y$ del mismo tipo donde depositaremos el resultado.

    Ahora bien, ¿Qué podemos asumir de $x$ e $y$ antes de ejecutar el programa? ¿Qué relación esperamos se cumpla entre $x$ e $y$ luego de la ejecución? Respondernos estas preguntas dará resultado a la \textit{especificación} del programa.

    De la descripción informal que enunciamos inicialmente, no se desprende ninguna relación particular entre $x$ e $y$ que deba valer al inicio de nuestro programa (más allá de las propiedades garantizadas por la definición del estado \footnote{Notemos que la definición de estado ya provee garantías intrínsicas: las constantes no modificarán su valor inicial y los valores de las variables y constantes serán del tipo correspondiente.}). Es decir, no hay una precondición en particular.

    Al finalizar el programa, queremos que en el estado el valor de $y$ sea estrictamente mayor a $x$. Ésta será nuestra postcondición.

    En efecto, nuestro programa será especificado por una \textit{precondición} y una \textit{postcondición}. Juntas, funcionan como contrato entre quien desarrolla el programa y quien lo ejecuta. Quien ejecuta el programa debe asegurar la precondición y puede asumir la postcondición al finalizar la ejecución. Quien lo desarolla puede asumir la precondición y debe asegurar la postcondición.

    Nos resultará útil la siguiente notación formal para especificar programas, que utiliza \textit{predicados} para escribir la precondición y la postcondición. En este caso:
    \begin{align*}
        & \declConst{x}{\mathbb{Z}}, \declVar{y}{\mathbb{Z}}\\
        & \{P: True\} \\
        & S \\
        & \{Q: y > x\}\\
    \end{align*}

    Primero declaramos las variables y constantes a las que el programa tendrá acceso. Y luego la Terna de Hoare que toma la forma $\{P\}S\{Q\}$, donde $S$ es el programa y $P$ y $Q$ predicados que definen la precondición y postcondición respectivamente. La terna se intrepreta así: 
    \begin{center}
        \textit{Cada vez que ejecutemos $S$ a partir de un estado que satisface $P$ llegaremos a un estado que satisface $Q$.}
    \end{center}
    

    En nuestro ejemplo $P$ es $True$, lo que simboliza no tener ninguna precondición en particular, puesto que cualquier estado posible satisface $True$. Y $Q$ es $y > x$.

    Hasta aquí, utilizando los conceptos de estado, predicados, y transformación de estado, hemos logrado especificar acabadamente qué debe hacer nuestro programa, aún sin hablar en absoluto de cómo lo hará.

    \subsubsection*{La especificación de un programa en Dafny}

    A lo largo de este trabajo, escribiremos programas formalmente especificados, y verificaremos a través de \textit{pruebas} que sus implementaciones sean correctas, eso es, verificar que efectivamente vale $\{P\}S\{Q\}$.

    Para ayudarnos en esta tarea, utilizaremos Dafny, un lenguaje de programación con soporte para declarar especificaciones, y dotado de un entorno de desarrollo capaz de verificar los programas de manera automática.

    Si bien para programas sencillos, como el de superar un número entero, la correctitud del programa será evidente con solo inspeccionarlo y para otros realizar las pruebas manualmente no será un gran desafío, a medida que construyamos programas más complejos descubriremos la practicidad de poder contar con un verificador automático.

    Escribamos entonces la especificación de nuestro programa en Dafny:

    \dafnyfile{Especificación de "superar un número entero"}{ejemplos/01_superar_especificacion.dfy}

    Hemos utilizado el constructor \inlinedafny{method} de Dafny para especificar nuestro programa. La presencia de $\declConst{x}{\mathbb{Z}}$ en el estado está reflejada por el parámetro \inlinedafny{x:int}, los parámetros de los métodos en Dafny son inmutables. Mientras que $\declVar{y}{\mathbb{Z}}$ está en el estado por la inclusión de \inlinedafny{y:int} en la cláusula \inlinedafny{returns}.
    La cláusula \inlinedafny{ensures y > x} se utiliza para especificar la postcondición.

    \subsubsection*{La asignación}
    Nuestro programa no tiene una implementación aún. La implementación de un programa imperativo estará dada por una sucesión de sentencias de varios tipos (que iremos introduciendo sucesivamente), y transforman el estado de una manera u otra. El primer tipo de sentencia que estudiaremos es la ``asignación''.

    Una asignación, que escribiremos como $x_1,...,x_n := E_1,...,E_n$, donde el término izquierdo es una sucesión de nombres de variables y el derecho un número igual de expresiones, transforma el estado del programa asignando a las variables del lado izquierdo los valores que resultan de evaluar las expresiones correspondientes del lado derecho en el estado actual.

    Dafny utiliza esta misma sintaxis para la asignación. Las variables que aparecen en el lado izquierdo deben haber sido declaradas previamente con una sentencia de declaración de variables, que toma la forma \inlinedafny{var x;}, o estar listadas entre los parámetros o valores de retorno del método.

    Las expresiones del lado derecho serán expresiones de Dafny válidas de cualquier tipo, pero por el momento nos concentraremos en expresiones aritméticas que combinan números y variables con los operadores aritméticos básicos $+,-,*,/,\%$

    Nos resultará natural utilizar la asignación para completar el cuerpo de nuestro programa:
    \dafnyfile{Implementación correcta de "superar un número entero"}{ejemplos/02_superar.dfy}
    Si corremos:
    \begin{verbatim}
        $ dafny verify ejemplos/02_superar.dfy
    \end{verbatim}
    veremos que Dafny automáticamente verifica la correctitud de este programa. Cómo lo hace? Cómo verifica Dafny que a partir de cualquier estado que satisface $True$, luego de ejecutar la asignación \inlinedafny{y := x + 1} se llega a un estado que satisface la postcondición $y > x$?

    Para entender esto, pensemos primero qué garantía puede darnos la ejecución de la asignación acerca del estado resultante. Por su definición, la asignación solo puede garantizarnos que luego de la ejecución se cumple $y = x + 1$, no más. A su vez, esto resulta suficiente para probar, por aritmética, que $y > x$.

    En cambio, si proponemos la implementación:
    \dafnyfile{Implementación incorrecta de "superar un número entero"}{ejemplos/03_superar_incorrecto.dfy}
    la única garantía provista por la asignación, post ejecución, es $y = x * 2$, que no garantiza, para todo estado posible inicial, $y > x$, puesto que para el estado inicial $\sigma:\{y=0,x=0\}$, si bien luego de la ejecución se cumple $y = x * 2 $, no se cumple $y > x$.

    En efecto, si corremos:
    \begin{verbatim}
        $ dafny verify ejemplos/03_superar_incorrecto.dfy
    \end{verbatim}
    Recibiremos como output:
    \begin{spverbatim}
    examples/03_superar_incorrecto.dfy(3,0): Error: a postcondition could not be proved on this return path
    \end{spverbatim}

    \subsubsection*{Precondición más débil y obligaciones de prueba}
    Notemos que la asignación nos exige una precondición mínima, a partir de la cual, podemos asegurar una postcondición $Q$ luego de ejecutar la asignación. En el primer caso era $True$, pues la asignación por si sola aseguraba la postcondición. En el segundo caso $x > 0$ pues de lo contrario no puede asegurarse la postcondición.
    Llamaremos a esta precondición, la \textit{precondición más débil} de la asignación respecto de $Q$ y la denotaremos $wp.(x := E).Q$ (por \textit{weakest precondition} en inglés).

    El primer paso que deber realizarse para intentar la verificación automática es calcular la $wp.(x := E).Q$.
    Esta puede obtenerse mecánicamente mediante la sustitución sintáctica en $Q$ de todas las ocurrencias de $x$ por $E$ (i.e. $Q[x := E]$) gracias al siguiente teorema.

    \textbf{Teorema}: Weakest Precondition de la asignación
    \footnote{Encerraremos un predicado entre corchetes [] para indicar que es válido para cualquier estado posible}
    \footnote{La prueba puede encontrarse en el Anexo I}
    \begin{align*}
        [ wp.(x:=E).Q \equiv Q[x:=E] ]
    \end{align*}
    Una interpretación útil de este teorema, es que lo único que podemos esperar de la asignación, es que realice la transformación de estado que le corresponde, el resto de la postcondición tiene que poder probarse a partir de la precondición.

    En nuestros ejemplos:
    \begin{align*}
        & wp.(y := x + 1).( y > x )\\
        & \equiv \text{\{ Teorema Weakest Precondition de la asignación \}}\\
        & x + 1 > x\\
        & \equiv \text{\{ aritmética \}}\\
        & True\\
    \end{align*}

    \begin{align*}
        & wp.(y := x * 2).( y > x )\\
        & \equiv \text{\{ Teorema Weakest Precondition de la asignación \}}\\
        & x * 2 > x\\
        & \equiv \text{\{ aritmética \}}\\
        & x > 0\\
    \end{align*}


    El segundo paso es demostrar que la precondición del programa implica la $wp$.
    Siguiendo con los ejemplos, demostrar $True \Rightarrow True$ en un caso y $True \Rightarrow x > 0$ en el otro.
    Llamaremos a estos predicados: obligaciones de prueba.

    Sabemos que no existe un método que pueda para probar la validez (o refutar) un predicado dado cualquiera. Sin embargo existen herramientas, como los SMT Solvers (Satisfiability Modulo Theory Solvers), que pueden intentar o bien probar su validez o bien encontrar un contrajemplo \cite{10.1007/978-3-030-99524-9_23}. Dafny utiliza SMT Solvers para intentar probar las obligaciones de prueba de manera automática. Si lo logra, entonces estamos seguros de la correctitud del programa. Si no lo logra, puede que el programa sea incorrecto (e incluso contemos con un contraejemplo), o bien que Dafny necesite asistencia en la prueba. En tal caso, Dafny nos permite introducir manualmente nuevos lemas y pruebas, que luego el SMT Solver puede aprovechar para verificar nuestro programa.

    \subsection{El valor absoluto de un número entero}
    [WIP]: (Introduccion del if)

    \subsection{La división de números enteros}
    Queremos obtener un programa que dados dos números $x$ e $y$, compute el cociente $q$ y el resto $r$ de la división entera de $x$ por $y$.
    Recordemos que el cociente y el resto cumplen:
    $$x = y * q + r$$
    Ahora bien, ¿cómo podemos computar $q$ y $r$, para cualquier $x$ e $y$ dados?
    Una alternativa razonable es construir iterativamente tanto $q$ como $r$, partiendo de valores iniciales y acercándolos en cada paso a su valor final.
    Si en todo momento, mantenemos la cantidad de $x$ distribuída entre cierta cantidad de $y$’s (esto es $q$) y el resto que falta para llegar a cubrir $x$ (esto es $r$), entonces podemos imaginar un ciclo en el que empezamos con $q$ igual a 0 y todo $x$ está en $r$.
    Luego en cada paso, y mientras podamos extraer una cantidad $y$ de $r$, la sustraemos de ahí y la pasamos a $q$.
    Es decir, empezamos con:
    \begin{verbatim}
        q:=0;
        r:=x;
    \end{verbatim}
    Y en cada paso mientras que $r \geq y$, ejecutamos
    \begin{verbatim}
        q:=q + 1;
        r:=r - y;
    \end{verbatim}

    Y así sucesivamente hasta que $y$ no quepe en $r$ ( $ y > r $ ). Para entonces $q$ y $r$ serán respectivamente el cociente y el resto de la división de $x$ por $y$.

    Nuestro programa final será:
    \begin{verbatim}
    q:=0;
    r:=x;
    do r >=y
        q:=q+1;
        r:=r-y;
    od
    \end{verbatim}
    Notemos en este programa simple, que:
    \begin{itemize}
        \item En todo momento se cumple:
        $$x = q * y + r$$
        Este es nuestro \textit{invariante}, y proviene de nuestra estrategia inicial de tener distribuído $x$, paso a paso, entre $q$ y $r$.
        \item Que debemos continuar iterando mientras que $r >= y$,
        Esta es nuestra \textit{guarda}.
        \item Que si se cumple el invariante y la guarda deja de cumplirse entonces hemos terminado.
        \item Y que a su vez, estamos seguros de que en algún momento la guarda dejará de cumplirse, por que en cada paso reducimos $r$.
    \end{itemize}

    Este desarrollo alternativo, pone foco en presentar al lector una estrategia de resolución iterativa del problema, acudiendo a la experiencia común entre las personas de ``pasar cosas'' de un lugar a otro, y cómo esa estrategia puede traducirse en un programa concreto.
    La esperanza, es que al finalizar la explicación, el lector esté en mejores condiciones de identificar otros problemas que puedan resolverse programando ciclos, y la importancia que el invariante adquiere como sostén de la estrategia iterativa de resolución.
    \chapter{Dafny}
    Continuará.

    \bibliography{References}
    \bibliographystyle{plain}
\end{document}
