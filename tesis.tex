\documentclass[12pt, a4paper, openany, fleqn]{book}
\usepackage{amsmath, amssymb,}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{relsize}
\usepackage[left=2.00cm, right=2.00cm, top=2.00cm, bottom=2.00cm]{geometry}
\usepackage{xcolor}
\usepackage{dafny}
\usepackage{spverbatim}

\renewcommand{\lstlistingname}{Dafny}
\linespread{1.1}
\author{Germán Ferrero}
\title{Construcción formal de programas asistida por Dafny}
\begin{document}
    \chapter{Introducción}
    En el libro Cálculo de Programas (en adelante simplemente ``el libro''), se busca introducir al estudiante en la construcción de programas imperativos a través de un método formal para derivar el programa a partir de su especificación. La misma debe estar definida por una precondición y una postcondición, ambas escritas como fórmulas del cálculo de predicados estudiado en la materia pre correlativa ``Introducción a los Algoritmos''. El método consiste en tender puentes entre los bloques constructivos de un lenguaje imperativo (\textit{if}, \textit{for}, asignación, \textit{skip}, etc) y el cálculo de predicados. De manera tal que uno pueda plantear el esqueleto de un programa de manera creativa, y concluir los detalles razonando - o calculando - sobre el terreno ya conocido del cálculo de predicados.

    En mi opinión el libro tiene algunas características que merecen revisión:
    \begin{itemize}
    \item Utiliza, de manera casi exclusiva, un lenguaje formal que privilegia la especificidad, pero sacrifica legibilidad y facilidad de interpretación.
    \item En ocasiones pasa por alto el origen de las estrategias creativas necesarias para construir programas, introduciendo ``esqueletos'' de programas sin mucho preámbulo, y restringiendo el foco de atención a la derivación de las sentencias que constituyen el resto del programa y sí pueden derivarse mediante el método formal.
    \item Los programas obtenidos y sus pruebas, no están escritos en computadora, y por tanto no pueden ser ejecutados ni verificados de forma automática.
    \end{itemize}

    Nuestra hipótesis, es que resultaría más provechoso para el proceso de aprendizaje, primero, introducir la programación imperativa con ejemplos en un lenguaje no formal. Luego, con el lector y su intuición a bordo, identificar en los ejemplos la utilidad de los conceptos básicos (transformación de estado, precondición, postcondición, invariante, etc) y finalmente proceder a la formalización de los mismos para luego poder probar (formalmente), la corrección de los programas obtenidos y resolver problemas más complejos asistidos por una metodología similar a la del libro pero adaptada al uso de Dafny, un lenguaje de programación con soporte para la declaración de especificaciones, pruebas y un entorno de desarrollo capaz de verificar los programas de manera automática.

    A lo largo de este trabajo desarrollamos esta estrategia alternativa.
    % TODO: Revisar más adelante qué texto resume mejor cada capítulo.%
    [WIP]
    En el capítulo 2 presentamos ejemplos de problemas simples que pueden resolverse con programación imperativa. Apelamos a la intuición y la creatividad para construir los programas e identificamos en ellos los conceptos fundamentales.
    En el capítulo 3 los formalizamos (...)
    En el capítulo 4 realizamos pruebas formales de correctitud utilizando Dafny. (...)[END-WIP]

    \chapter{Introducción a la programación imperativa}
    [WIP](...)

    \subsection{Superar un número entero}
    \subsubsection*{La especificación de un programa}

    Queremos obtener un programa $S$ que dado un número entero cualquiera nos devuelva otro mayor. Este simple programa, que finalmente resultará en una línea de código similar a esta:
    \begin{verbatim}
        y = x + 1  # Pseudocódigo
    \end{verbatim}
    nos servirá para razonar acerca de qué es un programa imperativo y cómo podemos garantizar su correctitud.

    En primer lugar, necesitamos ``recibir'' o ``leer'' de alguna forma el número en cuestión, para conocer su valor, y luego poder ``devolver'' o ``escribir'' de alguna forma otro valor mayor, una vez que lo calculemos.
    En la programación imperativa el mecanismo que utilizaremos para satisfacer ambas necesidades es el de \textit{transformación de estado}.
    Un \textit{estado} será una colección de nombres de variables y sus valores. Al \textit{ejecutar} un programa lo que estaremos haciendo es transformar potencialmente ese estado, sea agregando nuevas variables, modificando el valor de las variables existentes, o dejándolo tal cual lo recibimos.

    En este caso podemos pensar en un programa que se ejecutará a partir de un estado con una variable $x$, que aloja el valor de la cantidad a superar y una variable $y$ donde depositaremos el resultado.

    Ahora bien,
    ¿Qué hará el programa si $x$ no está en el estado al ser ejecutado?
    ¿Qué hará si el valor de $x$ no es un entero?
    ¿Qué relación esperamos se cumpla entre $x$ e $y$ luego de la ejecución?

    Respondernos estas preguntas puntillosamente dará resultado a la \textit{especificación} del programa.
    Decidiremos, por ejemplo, que no nos interesa qué sucede al ejecutar $S$ si $x$ no está en el estado y por tanto que $S$ nunca se ejecutará en ese caso. Lo mismo aplica en caso de que el valor de $x$ no sea un entero. Es decir, pondremos como precondición de nuestro programa que $x$ esté definida y su valor sea un número entero y que $y$ esté definida aunque su valor sea un número entero arbitrario. Por último queremos que nuestro programa garantice que en el estado final el valor de $y$ sea estrictamente mayor a $x$. Esta será nuestra postcondición.

    En efecto, nuestro programa será especificado por una \textit{precondición} y una \textit{postcondición}

    Aún quedan preguntas sin resolver:
    ¿Qué pasa si nuestro programa cumple con la postcondición, pero en el camino, no solo modificó $y$ sino también $x$? Para resolver este problema necesitamos que, para nuestro programa, $x$ no sea una variable sino una \textit{constante} (es decir, que no pueda ser modificada).
    ¿Algún otro programa estará consultando el estado además del nuestro?¿Tenemos que especificarle a nuestro programa que no modifique variables que no debe? Por el momento, pensaremos nuestro programa como el único que leerá y escribirá el estado. Puede modificar las variables que desee, siempre que cumpla con la postcondición.

    Nos resultará muy útil emplear \textit{predicados} para escribir la precondición y la postcondición de nuestros programas. En este caso:

    \begin{align*}
        [[& \text{const x} \in \mathbb{Z} \\
          & \text{var y} \in \mathbb{Z} \\
          & \lbrace {True} \rbrace \\
          & S \\
          & \lbrace {y > x} \rbrace \\
        ]]
    \end{align*}

    Notese que la precondición es $True$ pues lo único que debe cumplirse es la existencia de la constante $x$ y la variable $y$ en el estado.
    Hasta aquí, utilizando los conceptos de estado, predicados, y transformación de estados, hemos logrado especificar acabadamente qué debería hacer nuestro programa, aún sin hablar en absoluto de cómo lo hará.

    \subsubsection*{La especificación de un programa en Dafny}

    A lo largo de este trabajo, escribiremos programas formalmente especificados, y verificaremos a través de \textit{pruebas} que sus implementaciones sean correctas, es decir, que cumplan con su especificación.

    Para ayudarnos en esta tarea, utilizaremos Dafny un lenguaje de programación con soporte para declarar especificaciones, y dotado de un entorno de desarrollo capaz de verificar los programas de manera automática.

    Si bien, para programas sencillos como el superar un número entero, la correctitud del programa será evidente con solo inspeccionarlo, a medida que construyamos programas más complejos descubriremos la invaluable tranquilidad de saber que la correctitud de nuestro programa ha sido verificada de manera automática.

    Escribamos entonces la especificación de nuestro programa en Dafny:

    \dafnyfile{ejemplos/01_superar_especificacion.dfy}

    Hemos utilizado el constructor \inlinedafny{method} de Dafny para especificar nuestro programa. La precondición de que exista la constante \begin{math}x \in \mathbb{Z}\end{math}, está especificada por el parámetro \inlinedafny{x:int}, los parámetros de los métodos en Dafny son inmutables. La precondición de que exista la variable \begin{math}y \in \mathbb{Z}\end{math} está especificada por la presencia de \inlinedafny{y:int} en la cláusula \inlinedafny{returns}.
    La postcondición está especificada por la cláusula \inlinedafny{ensures y > x} que especifica la relación que el programa garantiza entre $x$ e $y$ al final de la ejecución.

    \subsubsection*{La asignación}
    Nuestro programa no tiene un cuerpo o implementación aún. El cuerpo de un programa imperativo estará dado por una sucesión de sentencias de varios tipos, bien definidos, que transforman el estado de una manera u otra. El primer tipo de sentencia que estudiaremos es la ``asignación''.

    Una asignación, que escribiremos como $x:=E$, donde $x$ es una sucesión de nombres de variables y $E$ un número igual de expresiones, transforma el estado del programa, asignando a las variables del lado izquierdo los valores que resultan de evaluar las expresiones correspondientes del lado derecho en el estado actual.
    \begin{align*}
        & \text{[WIP: posible candidata para simbolizar operatoria sobre estados]} \\
        & (x := E).\sigma = \sigma[x:=E.\sigma]
    \end{align*}

    En Dafny, también, la asignación toma la forma \inlinedafny{x, y := E, E';}.

    Las variables que aparecen en el lado izquierdo deben haber sido declaradas previamente con una sentencia de declaración de variables, que toma la forma \inlinedafny{var x;}, o estar listadas entre los parámetros o valores de retorno del método.

    Las expresiones del lado derecho pueden ser cualquier tipo de expresión en Dafny, pero por el momento nos concentraremos en expresiones aritméticas que combinan números y variables con los operadores aritméticos básicos $+,-,*,/,\%$

    Nos resultará natural utilizar la asignación para completar el cuerpo de nuestro programa:
    \dafnyfile{ejemplos/02_superar.dfy}
    Si corremos:
    \begin{verbatim}
        $ dafny verify ejemplos/02_superar.dfy
    \end{verbatim}
    veremos que Dafny automáticamente verifica la correctitud de este programa. Cómo lo hace? Cómo resuelve Dafny que a partir de la precondición $\{True\}$, si ejecutamos la asignación \inlinedafny{y := x + 1} se cumple la postcondición $\{ y > x \}$?

    Para entender esto, pensemos primero qué garantía pude darnos la ejecución de la asignación acerca del estado resultante. Por su definición, la asignación solo puede garantizarnos que luego de la ejecución se cumple $\{ y = x + 1 \}$, no más. A su vez, esto resulta suficiente para probar, por aritmética, que $\{ y > x \}$.

    En cambio, si proponemos la implementación:
    \dafnyfile{ejemplos/03_superar_incorrecto.dfy}
    la única garantía provista por la asignación, post ejecución, es $\{ y = x * 2 \}$, que no garantiza, para todo estado posible, $\{ y > x \}$, puesto que hay uno: $\sigma\{y=0,x=0\}$ para el cual se cumple $\{ y = x * 2 \}$ y no se cumple $\{ y > x \}$. En este caso, para que el programa sea correcto, necesitaríamos introducir como precondición de nuestro programa $\{ x > 0 \}$.

    En efecto, si corremos:
    \begin{verbatim}
        $ dafny verify ejemplos/03_superar_incorrecto.dfy
    \end{verbatim}
    Recibiremos como output:
    \begin{spverbatim}
    examples/03_superar_incorrecto.dfy(3,0): Error: a postcondition could not be proved on this return path
    \end{spverbatim}

    Notemos que la asignación nos impone una precondición mínima, a partir de la cual, podemos asegurar una postcondición luego de ejecutar la asignación. En el primer caso era $\{True\}$, pues la asignación por si sola aseguraba la postcondición. En el segundo caso $\{ x > 0 \}$ pues de lo contrario no podía asegurarse la postcondición.
    En términos generales, llamaremos a esta precondición mínima o \textit{precondición más débil} de la asignación $x:=E$ respecto a una postcondición $Q$, $wp.(x := E).Q$ (por \textit{weakest precondition} en inglés).

    El primer paso que realiza Dafny para la verificación automática es calcular la $wp.(x := E).Q$.
    Esta puede obtenerse mecánicamente mediante la sustitución sintáctica en $Q$ de todas las ocurrencias de $x$ por $E$ (i.e. $Q[x := E]$)

    \begin{align*}
        [ wp.(x:=E).Q \equiv Q[x:=E] ]
    \end{align*}

    Una interpretación útil de este teorema, es que lo único que podemos esperar de la asignación, es que realice la transformación de estado que le corresponde, el resto de la postcondición tiene que valer por cuenta de la precondición.

    En nuestros ejemplos:
    \begin{align*}
        & wp.(y := x + 1).\{ y > x \} \equiv \{ x + 1 > x \} \equiv \{ True \} \\
        & wp.(y := x * 2).\{ y > x \} \equiv \{ x * 2 > x \} \equiv \{ x > 0 \}
    \end{align*}


    El segundo paso es demostrar que la precondición del programa del programa implica la $wp$.
    Siguiendo con los ejemplos:
    \begin{align*}
        & True \Rightarrow True \\
        & True \Rightarrow x > 0
    \end{align*}

    Dafny delega esta prueba en herramientas llamadas SMT Solvers (Satisfiability modulo theories Solvers). En particular en uno: ``Z3'' desarrollado por Microsoft, al igual que Dafny.

    \subsection{El valor absoluto de un número entero}
    [WIP]: (Introduccion del if)

    \subsection{La división de números enteros}
    Queremos obtener un programa que dados dos números $x$ e $y$, compute el cociente $q$ y el resto $r$ de la división entera de $x$ por $y$.
    Recordemos que el cociente y el resto cumplen:
    $$x = y * q + r$$
    Ahora bien, ¿cómo podemos computar $q$ y $r$, para cualquier $x$ e $y$ dados?
    Una alternativa razonable es construir iterativamente tanto $q$ como $r$, partiendo de valores iniciales y acercándolos en cada paso a su valor final.
    Si en todo momento, mantenemos la cantidad de $x$ distribuída entre cierta cantidad de $y$’s (esto es $q$) y el resto que falta para llegar a cubrir $x$ (esto es $r$), entonces podemos imaginar un ciclo en el que empezamos con $q$ igual a 0 y todo $x$ está en $r$.
    Luego en cada paso, y mientras podamos extraer una cantidad $y$ de $r$, la sustraemos de ahí y la pasamos a $q$.
    Es decir, empezamos con:
    \begin{verbatim}
        q:=0;
        r:=x;
    \end{verbatim}
    Y en cada paso mientras que $r \geq y$, ejecutamos
    \begin{verbatim}
        q:=q + 1;
        r:=r - y;
    \end{verbatim}

    Y así sucesivamente hasta que $y$ no quepe en $r$ ( $ y > r $ ). Para entonces $q$ y $r$ serán respectivamente el cociente y el resto de la división de $x$ por $y$.

    Nuestro programa final será:
    \begin{verbatim}
    q:=0;
    r:=x;
    do r >=y
        q:=q+1;
        r:=r-y;
    od
    \end{verbatim}
    Notemos en este programa simple, que:
    \begin{itemize}
        \item En todo momento se cumple:
        $$x = q * y + r$$
        Este es nuestro \textit{invariante}, y proviene de nuestra estrategia inicial de tener distribuído $x$, paso a paso, entre $q$ y $r$.
        \item Que debemos continuar iterando mientras que $r >= y$,
        Esta es nuestra \textit{guarda}.
        \item Que si se cumple el invariante y la guarda deja de cumplirse entonces hemos terminado.
        \item Y que a su vez, estamos seguros de que en algún momento la guarda dejará de cumplirse, por que en cada paso reducimos $r$.
    \end{itemize}

    Este desarrollo alternativo, pone foco en presentar al lector una estrategia de resolución iterativa del problema, acudiendo a la experiencia común entre las personas de ``pasar cosas'' de un lugar a otro, y cómo esa estrategia puede traducirse en un programa concreto.
    La esperanza, es que al finalizar la explicación, el lector esté en mejores condiciones de identificar otros problemas que puedan resolverse programando ciclos, y la importancia que el invariante adquiere como sostén de la estrategia iterativa de resolución.
    \chapter{Dafny}
    Continuará.
\end{document}
